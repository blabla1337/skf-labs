# KBID 67 Open Redirect Harder 2

## Running the app nodeJs

First make sure nodejs and npm are installed on your host machine.
After installation, we go to the folder of the lab we want to practice.
"i.e /skf-labs/XSS, /skf-labs/RFI/" and run the following commands:

```
$ npm install
```

```
$ npm start
```

{% hint style="success" %}
Now that the app is running let's go hacking!
{% endhint %}

## Reconnaissance

### Step 1

The application shows that there is a new version of the website available somewhere, and a click on the button "Go to new website" will redirect you to it.

If we click on the button we will be redirected on the new page [http://localhost:5000/newsite](http://localhost:5000/newsite)

### Step 2

Intercepting the traffic generated by the application, we note that the redirection is performed using the following call

```text
GET /redirect?newurl=newsite
```

that will generate a 302 Redirect response from the server

Exactly like in the previous example \(KBID-67-Url-redirecttion\). If we look at the code we discover a tiny difference: a blacklist!

```javascript
let newurl = req.query.newurl;
if (blacklist(newurl)) {
  res.render("index.ejs", {
    content: 'Sorry, you cannot use "." or "/" in the redirect. Good luck!',
  });
} else res.redirect(302, newurl);
```

If we look at the blacklist definition, we can immediately see that the URL, in order to be valid, must not contain any "." \(dot\) and "/\" (forward slash).

```javascript
const blacklist = (newurl) => {
  if (newurl.includes(".") || newurl.includes("/")) {
    return true;
  }
  return false;
};
```

### Step 3

Let's verify the effectiveness of this blacklist. If we try to exploit the unvalidated redirect using an external website, we see that the application blocks us, returning an error in the page.

If we URL encode the dot the application is smart enough to decode it and recognise it in the URL, blocking us again.

## Exploitation

Although we cannot explicitly use the dot character, we can find different ways to bypass the blacklist. In example we could use the following techniques:

- double encoding: `https://google%252ecom`
- UTF-8 encoding: `https://google.com%E3%80%82com`
- Can you find more?

The "." (dot) blacklist bypass is done, now it's time of "\/" (forward slash).

Double encoding won't work on this case because the browser doesn't understand the URL redirection of duble encoded "/\".

With HTTPS protocol, the "\/" can be omitted. The browser will understand this URL and fix the "mistake" and will add the missing protocol double forward slashes.

Therefore, the final payload is:

```text
http://localhost:5000/redirect?newurl=https:google%252ecom
```

- Can you find more ways to bypass "\/" blacklist validation?

Using the payload above we will be able to successfully redirect a user to a malicious website

## Additional sources

{% embed url="https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/11-Client_Side_Testing/04-Testing_for_Client_Side_URL_Redirect" %}
