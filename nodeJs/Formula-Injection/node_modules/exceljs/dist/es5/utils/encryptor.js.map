{"version":3,"sources":["../../../lib/utils/encryptor.js"],"names":["crypto","require","Encryptor","hash","algorithm","createHash","buffers","update","Buffer","concat","digest","convertPasswordToHash","password","hashAlgorithm","saltValue","spinCount","toLowerCase","hashes","getHashes","indexOf","Error","passwordBuffer","from","key","i","iterator","alloc","writeUInt32LE","toString","randomBytes","size","module","exports"],"mappings":"AAAA;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AAEA,IAAMC,SAAS,GAAG;AAChB;;;;;AAKAC,EAAAA,IANgB,gBAMXC,SANW,EAMY;AAC1B,QAAMD,IAAI,GAAGH,MAAM,CAACK,UAAP,CAAkBD,SAAlB,CAAb;;AAD0B,sCAATE,OAAS;AAATA,MAAAA,OAAS;AAAA;;AAE1BH,IAAAA,IAAI,CAACI,MAAL,CAAYC,MAAM,CAACC,MAAP,CAAcH,OAAd,CAAZ;AACA,WAAOH,IAAI,CAACO,MAAL,EAAP;AACD,GAVe;;AAWhB;;;;;;;;;;AAUAC,EAAAA,qBArBgB,iCAqBMC,QArBN,EAqBgBC,aArBhB,EAqB+BC,SArB/B,EAqB0CC,SArB1C,EAqBqD;AACnEF,IAAAA,aAAa,GAAGA,aAAa,CAACG,WAAd,EAAhB;AACA,QAAMC,MAAM,GAAGjB,MAAM,CAACkB,SAAP,EAAf;;AACA,QAAID,MAAM,CAACE,OAAP,CAAeN,aAAf,IAAgC,CAApC,EAAuC;AACrC,YAAM,IAAIO,KAAJ,2BAA6BP,aAA7B,sBAAN;AACD,KALkE,CAOnE;;;AACA,QAAMQ,cAAc,GAAGb,MAAM,CAACc,IAAP,CAAYV,QAAZ,EAAsB,SAAtB,CAAvB,CARmE,CASnE;;AACA,QAAIW,GAAG,GAAG,KAAKpB,IAAL,CAAUU,aAAV,EAAyBL,MAAM,CAACc,IAAP,CAAYR,SAAZ,EAAuB,QAAvB,CAAzB,EAA2DO,cAA3D,CAAV,CAVmE,CAWnE;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,SAApB,EAA+BS,CAAC,EAAhC,EAAoC;AAClC,UAAMC,QAAQ,GAAGjB,MAAM,CAACkB,KAAP,CAAa,CAAb,CAAjB,CADkC,CAElC;AACA;;AACAD,MAAAA,QAAQ,CAACE,aAAT,CAAuBH,CAAvB,EAA0B,CAA1B;AACAD,MAAAA,GAAG,GAAG,KAAKpB,IAAL,CAAUU,aAAV,EAAyBU,GAAzB,EAA8BE,QAA9B,CAAN;AACD;;AACD,WAAOF,GAAG,CAACK,QAAJ,CAAa,QAAb,CAAP;AACD,GAzCe;;AA0ChB;;;;AAIAC,EAAAA,WA9CgB,uBA8CJC,IA9CI,EA8CE;AAChB,WAAO9B,MAAM,CAAC6B,WAAP,CAAmBC,IAAnB,CAAP;AACD;AAhDe,CAAlB;AAkDAC,MAAM,CAACC,OAAP,GAAiB9B,SAAjB","sourcesContent":["'use strict';\r\n\r\nconst crypto = require('crypto');\r\n\r\nconst Encryptor = {\r\n  /**\r\n   * Calculate a hash of the concatenated buffers with the given algorithm.\r\n   * @param {string} algorithm - The hash algorithm.\r\n   * @returns {Buffer} The hash\r\n   */\r\n  hash(algorithm, ...buffers) {\r\n    const hash = crypto.createHash(algorithm);\r\n    hash.update(Buffer.concat(buffers));\r\n    return hash.digest();\r\n  },\r\n  /**\r\n   * Convert a password into an encryption key\r\n   * @param {string} password - The password\r\n   * @param {string} hashAlgorithm - The hash algoritm\r\n   * @param {string} saltValue - The salt value\r\n   * @param {number} spinCount - The spin count\r\n   * @param {number} keyBits - The length of the key in bits\r\n   * @param {Buffer} blockKey - The block key\r\n   * @returns {Buffer} The encryption key\r\n   */\r\n  convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {\r\n    hashAlgorithm = hashAlgorithm.toLowerCase();\r\n    const hashes = crypto.getHashes();\r\n    if (hashes.indexOf(hashAlgorithm) < 0) {\r\n      throw new Error(`Hash algorithm '${hashAlgorithm}' not supported!`);\r\n    }\r\n\r\n    // Password must be in unicode buffer\r\n    const passwordBuffer = Buffer.from(password, 'utf16le');\r\n    // Generate the initial hash\r\n    let key = this.hash(hashAlgorithm, Buffer.from(saltValue, 'base64'), passwordBuffer);\r\n    // Now regenerate until spin count\r\n    for (let i = 0; i < spinCount; i++) {\r\n      const iterator = Buffer.alloc(4);\r\n      // this is the 'special' element of Excel password hashing\r\n      // that stops us from using crypto.pbkdf2()\r\n      iterator.writeUInt32LE(i, 0);\r\n      key = this.hash(hashAlgorithm, key, iterator);\r\n    }\r\n    return key.toString('base64');\r\n  },\r\n  /**\r\n   * Generates cryptographically strong pseudo-random data.\r\n   * @param size The size argument is a number indicating the number of bytes to generate.\r\n   */\r\n  randomBytes(size) {\r\n    return crypto.randomBytes(size);\r\n  },\r\n};\r\nmodule.exports = Encryptor;\r\n"],"file":"encryptor.js"}