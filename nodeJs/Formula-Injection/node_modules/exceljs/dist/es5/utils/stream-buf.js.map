{"version":3,"sources":["../../../lib/utils/stream-buf.js"],"names":["Stream","require","utils","StringBuf","StringChunk","data","encoding","_data","_encoding","target","targetOffset","offset","length","toBuffer","copy","_buffer","Buffer","from","StringBufChunk","_buf","BufferChunk","ReadWriteBuf","size","buffer","alloc","iRead","iWrite","buf","undefined","chunk","Math","min","StreamBuf","options","bufSize","buffers","batch","corked","inPos","outPos","pipes","paused","inherits","Duplex","concat","map","rwBuf","_getWritableBuffer","last","full","push","_pipe","write","pipe","Promise","resolve","all","_writeToBuffers","inLen","callback","Function","nop","String","ArrayBuffer","Error","shift","process","nextTick","emit","cork","_flush","uncork","end","writeComplete","error","forEach","read","eod","first","filter","Boolean","setEncoding","pause","resume","isPaused","destination","unpipe","unshift","wrap","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable max-classes-per-file */\r\nconst Stream = require('readable-stream');\r\n\r\nconst utils = require('./utils');\r\nconst StringBuf = require('./string-buf');\r\n\r\n// =============================================================================\r\n// data chunks - encapsulating incoming data\r\nclass StringChunk {\r\n  constructor(data, encoding) {\r\n    this._data = data;\r\n    this._encoding = encoding;\r\n  }\r\n\r\n  get length() {\r\n    return this.toBuffer().length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    return this.toBuffer().copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    if (!this._buffer) {\r\n      this._buffer = Buffer.from(this._data, this._encoding);\r\n    }\r\n    return this._buffer;\r\n  }\r\n}\r\n\r\nclass StringBufChunk {\r\n  constructor(data) {\r\n    this._data = data;\r\n  }\r\n\r\n  get length() {\r\n    return this._data.length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    // eslint-disable-next-line no-underscore-dangle\r\n    return this._data._buf.copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    return this._data.toBuffer();\r\n  }\r\n}\r\n\r\nclass BufferChunk {\r\n  constructor(data) {\r\n    this._data = data;\r\n  }\r\n\r\n  get length() {\r\n    return this._data.length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    this._data.copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    return this._data;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ReadWriteBuf - a single buffer supporting simple read-write\r\nclass ReadWriteBuf {\r\n  constructor(size) {\r\n    this.size = size;\r\n    // the buffer\r\n    this.buffer = Buffer.alloc(size);\r\n    // read index\r\n    this.iRead = 0;\r\n    // write index\r\n    this.iWrite = 0;\r\n  }\r\n\r\n  toBuffer() {\r\n    if (this.iRead === 0 && this.iWrite === this.size) {\r\n      return this.buffer;\r\n    }\r\n\r\n    const buf = Buffer.alloc(this.iWrite - this.iRead);\r\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\r\n    return buf;\r\n  }\r\n\r\n  get length() {\r\n    return this.iWrite - this.iRead;\r\n  }\r\n\r\n  get eod() {\r\n    return this.iRead === this.iWrite;\r\n  }\r\n\r\n  get full() {\r\n    return this.iWrite === this.size;\r\n  }\r\n\r\n  read(size) {\r\n    let buf;\r\n    // read size bytes from buffer and return buffer\r\n    if (size === 0) {\r\n      // special case - return null if no data requested\r\n      return null;\r\n    }\r\n\r\n    if (size === undefined || size >= this.length) {\r\n      // if no size specified or size is at least what we have then return all of the bytes\r\n      buf = this.toBuffer();\r\n      this.iRead = this.iWrite;\r\n      return buf;\r\n    }\r\n\r\n    // otherwise return a chunk\r\n    buf = Buffer.alloc(size);\r\n    this.buffer.copy(buf, 0, this.iRead, size);\r\n    this.iRead += size;\r\n    return buf;\r\n  }\r\n\r\n  write(chunk, offset, length) {\r\n    // write as many bytes from data from optional source offset\r\n    // and return number of bytes written\r\n    const size = Math.min(length, this.size - this.iWrite);\r\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\r\n    this.iWrite += size;\r\n    return size;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// StreamBuf - a multi-purpose read-write stream\r\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\r\n//  As StreamHub - pipe to multiple writables\r\n//  As readable stream - feed data into the writable part and have some other code read from it.\r\n\r\n// Note: Not sure why but StreamBuf does not like JS \"class\" sugar. It fails the\r\n// integration tests\r\nconst StreamBuf = function(options) {\r\n  options = options || {};\r\n  this.bufSize = options.bufSize || 1024 * 1024;\r\n  this.buffers = [];\r\n\r\n  // batch mode fills a buffer completely before passing the data on\r\n  // to pipes or 'readable' event listeners\r\n  this.batch = options.batch || false;\r\n\r\n  this.corked = false;\r\n  // where in the current writable buffer we're up to\r\n  this.inPos = 0;\r\n\r\n  // where in the current readable buffer we've read up to\r\n  this.outPos = 0;\r\n\r\n  // consuming pipe streams go here\r\n  this.pipes = [];\r\n\r\n  // controls emit('data')\r\n  this.paused = false;\r\n\r\n  this.encoding = null;\r\n};\r\n\r\nutils.inherits(StreamBuf, Stream.Duplex, {\r\n  toBuffer() {\r\n    switch (this.buffers.length) {\r\n      case 0:\r\n        return null;\r\n      case 1:\r\n        return this.buffers[0].toBuffer();\r\n      default:\r\n        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));\r\n    }\r\n  },\r\n\r\n  // writable\r\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\r\n  // finish - end() has been called\r\n  // pipe(src) - pipe() has been called on readable\r\n  // unpipe(src) - unpipe() has been called on readable\r\n  // error - duh\r\n\r\n  _getWritableBuffer() {\r\n    if (this.buffers.length) {\r\n      const last = this.buffers[this.buffers.length - 1];\r\n      if (!last.full) {\r\n        return last;\r\n      }\r\n    }\r\n    const buf = new ReadWriteBuf(this.bufSize);\r\n    this.buffers.push(buf);\r\n    return buf;\r\n  },\r\n\r\n  async _pipe(chunk) {\r\n    const write = function(pipe) {\r\n      return new Promise(resolve => {\r\n        pipe.write(chunk.toBuffer(), () => {\r\n          resolve();\r\n        });\r\n      });\r\n    };\r\n    await Promise.all(this.pipes.map(write));\r\n  },\r\n  _writeToBuffers(chunk) {\r\n    let inPos = 0;\r\n    const inLen = chunk.length;\r\n    while (inPos < inLen) {\r\n      // find writable buffer\r\n      const buffer = this._getWritableBuffer();\r\n\r\n      // write some data\r\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\r\n    }\r\n  },\r\n  async write(data, encoding, callback) {\r\n    if (encoding instanceof Function) {\r\n      callback = encoding;\r\n      encoding = 'utf8';\r\n    }\r\n    callback = callback || utils.nop;\r\n\r\n    // encapsulate data into a chunk\r\n    let chunk;\r\n    if (data instanceof StringBuf) {\r\n      chunk = new StringBufChunk(data);\r\n    } else if (data instanceof Buffer) {\r\n      chunk = new BufferChunk(data);\r\n    } else if (typeof data === 'string' || data instanceof String || data instanceof ArrayBuffer) {\r\n      chunk = new StringChunk(data, encoding);\r\n    } else {\r\n      throw new Error('Chunk must be one of type String, Buffer or StringBuf.');\r\n    }\r\n\r\n    // now, do something with the chunk\r\n    if (this.pipes.length) {\r\n      if (this.batch) {\r\n        this._writeToBuffers(chunk);\r\n        while (!this.corked && this.buffers.length > 1) {\r\n          this._pipe(this.buffers.shift());\r\n        }\r\n      } else if (!this.corked) {\r\n        await this._pipe(chunk);\r\n        callback();\r\n      } else {\r\n        this._writeToBuffers(chunk);\r\n        process.nextTick(callback);\r\n      }\r\n    } else {\r\n      if (!this.paused) {\r\n        this.emit('data', chunk.toBuffer());\r\n      }\r\n\r\n      this._writeToBuffers(chunk);\r\n      this.emit('readable');\r\n    }\r\n\r\n    return true;\r\n  },\r\n  cork() {\r\n    this.corked = true;\r\n  },\r\n  _flush(/* destination */) {\r\n    // if we have comsumers...\r\n    if (this.pipes.length) {\r\n      // and there's stuff not written\r\n      while (this.buffers.length) {\r\n        this._pipe(this.buffers.shift());\r\n      }\r\n    }\r\n  },\r\n  uncork() {\r\n    this.corked = false;\r\n    this._flush();\r\n  },\r\n  end(chunk, encoding, callback) {\r\n    const writeComplete = error => {\r\n      if (error) {\r\n        callback(error);\r\n      } else {\r\n        this._flush();\r\n        this.pipes.forEach(pipe => {\r\n          pipe.end();\r\n        });\r\n        this.emit('finish');\r\n      }\r\n    };\r\n    if (chunk) {\r\n      this.write(chunk, encoding, writeComplete);\r\n    } else {\r\n      writeComplete();\r\n    }\r\n  },\r\n\r\n  // readable\r\n  // event readable - some data is now available\r\n  // event data - switch to flowing mode - feeds chunks to handler\r\n  // event end - no more data\r\n  // event close - optional, indicates upstream close\r\n  // event error - duh\r\n  read(size) {\r\n    let buffers;\r\n    // read min(buffer, size || infinity)\r\n    if (size) {\r\n      buffers = [];\r\n      while (size && this.buffers.length && !this.buffers[0].eod) {\r\n        const first = this.buffers[0];\r\n        const buffer = first.read(size);\r\n        size -= buffer.length;\r\n        buffers.push(buffer);\r\n        if (first.eod && first.full) {\r\n          this.buffers.shift();\r\n        }\r\n      }\r\n      return Buffer.concat(buffers);\r\n    }\r\n\r\n    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);\r\n    this.buffers = [];\r\n    return Buffer.concat(buffers);\r\n  },\r\n  setEncoding(encoding) {\r\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\r\n    this.encoding = encoding;\r\n  },\r\n  pause() {\r\n    this.paused = true;\r\n  },\r\n  resume() {\r\n    this.paused = false;\r\n  },\r\n  isPaused() {\r\n    return !!this.paused;\r\n  },\r\n  pipe(destination) {\r\n    // add destination to pipe list & write current buffer\r\n    this.pipes.push(destination);\r\n    if (!this.paused && this.buffers.length) {\r\n      this.end();\r\n    }\r\n  },\r\n  unpipe(destination) {\r\n    // remove destination from pipe list\r\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\r\n  },\r\n  unshift(/* chunk */) {\r\n    // some numpty has read some data that's not for them and they want to put it back!\r\n    // Might implement this some day\r\n    throw new Error('Not Implemented');\r\n  },\r\n  wrap(/* stream */) {\r\n    // not implemented\r\n    throw new Error('Not Implemented');\r\n  },\r\n});\r\n\r\nmodule.exports = StreamBuf;\r\n"],"file":"stream-buf.js"}